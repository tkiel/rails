h2. Active Model Basics

This guide should provide you with all you need to get started using model classes. Active Model allow for Action Pack helpers to interact with non-ActiveRecord models. Active Model also helps building custom ORMs for use outside of the Rails framework.

endprologue.

WARNING. This Guide is based on Rails 3.0. Some of the code shown here will not work in earlier versions of Rails.

h3. Introduction

Active Model is a library containing various modules used in developing frameworks that need to interact with the Rails Action Pack library. Active Model provides a known set of interfaces for usage in classes. Some of modules are explained below -  

h4. AttributeMethods

AttributeMethods module can add custom prefixes and suffixes on methods of a class. It is used by defining the prefixes and suffixes, which methods on the object will use them.

<ruby>
class Person
  include ActiveModel::AttributeMethods

  attribute_method_prefix 'reset_'
  attribute_method_suffix '_highest?'
  define_attribute_methods ['age']

  attr_accessor :age

private
  def reset_attribute(attribute)
    send("#{attribute}=", 0)
  end

  def attribute_highest?(attribute)
    send(attribute) > 100 ? true : false
  end
  
end

person = Person.new
person.age = 110
person.age_highest?  # true
person.reset_age     # 0
person.age_highest?  # false 

</ruby>

h4. Callbacks

Callbacks gives Active Record style callbacks. This provides the ability to define the callbacks and those will run at appropriate time. After defining a callbacks you can wrap with before, after and around custom methods.

<ruby>
class Person
  extend ActiveModel::Callbacks

  define_model_callbacks :update

  before_update :reset_me

  def update
    _run_update_callbacks do
      # This will call when we are trying to call update on object.
    end
  end

  def reset_me
    # This method will call when you are calling update on object as a before_update callback as defined.
  end
end
</ruby>

h4. Conversion

If a class defines persisted? and id methods then you can include Conversion module in that class and you can able to call Rails conversion methods to objects of that class.

<ruby>
class Person
  include ActiveModel::Conversion

  def persisted?
    false
  end

  def id
    nil
  end
end

person = Person.new
person.to_model == person  #=> true
person.to_key              #=> nil
person.to_param            #=> nil
</ruby>

h3. Changelog

* August 5, 2011: Initial version by "Arun Agrawal":http://github.com/arunagw